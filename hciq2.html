<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HCI: The Human Factor Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* FONT: Open Sans for optimal readability at small sizes */
        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Open Sans', sans-serif;
            /* CHANGE: Body background set to #1B1B1B */
            background-color: #1B1B1B; 
            overflow-x: hidden; 
        }

        .option-label {
            display: block;
            padding: 0.6rem 1rem; 
            border: 1px solid #4a5568;
            border-radius: 0.75rem; 
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            margin-bottom: 0.75rem;
            color: #d1d5db;
            text-align: left;
            font-size: 0.9rem; 
        }
        .option-label:not(.answered):hover {
            /* Kept a darker gray (#111827) for visual contrast/depressed effect */
            background-color: #111827; 
            border-color: #60a5fa;
        }
        .option-label.selected {
            /* Kept a darker gray (#111827) for visual contrast/depressed effect */
            background-color: #111827; 
            border-color: #60a5fa;
        }
        .option-label.correct {
            background-color: #14532d;
            border-color: #22c55e;
            color: #ffffff;
        }
        .option-label.incorrect {
            background-color: #7f1d1d;
            border-color: #ef4444;
            color: #ffffff;
        }
        .option-label.disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }
        
        /* === UNIFIED BUTTON SIZE/PADDING (Applies to all three buttons) === */
        .btn {
            padding: 0.4rem 0.8rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            border: none; 
            cursor: pointer;
            display: inline-block;
            font-size: 0.8rem;
        }
        /* === END UNIFIED BUTTON SIZE/PADDING === */

        /* Primary buttons (Check Answer, Next) are orange/yellow */
        .btn-primary {
            background-color: #FCA300; 
            color: #111827; 
            border: none;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #e59400; 
        }

        /* Secondary button (Previous) remains gray/transparent */
        .btn-secondary {
            background-color: transparent;
            color: #9ca3af; 
            border: 1px solid #4a5568; 
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #111827; 
            color: #ffffff;
            border-color: #9ca3af; 
        }
        /* Style for disabled buttons */
        .btn:disabled {
            opacity: 0.4; 
            cursor: not-allowed;
        }

        .explanation {
            margin-top: 0.75rem; 
            padding: 0.75rem; 
            border-left: 5px solid #3b82f6;
            /* CHANGE: Explanation background set to #1B1B1B */
            background-color: #1B1B1B;
            color: #d1d5db;
            border-radius: 0.5rem;
            font-size: 0.85rem; 
        }
    </style>
</head>
<body class="bg-[#1B1B1B] p-4">

    <main id="quiz-container" class="w-full mx-auto max-w-2xl">
        <div id="quiz-content" class="bg-[#1B1B1B] p-4"> 
            
            <div id="question-navigation" class="text-left text-sm font-medium text-gray-400 mb-4">
                <span id="current-question-number"></span> / <span id="total-questions"></span>
            </div>
            
            <div id="current-question-container" class="space-y-6"> 
                </div>

            <div id="feedback-area" class="mt-3 hidden"> 
                <div id="explanation-text" class="explanation"></div>
            </div>

            <div class="flex flex-wrap justify-between items-start mt-8 gap-3"> 
                <button id="prev-btn" class="btn btn-secondary" disabled>Previous</button>
                
                <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3 ml-auto">
                    <button id="check-answer-btn" class="btn btn-primary">Check Answer</button>
                    <button id="next-btn" class="btn btn-primary" disabled>Next</button>
                </div>
            </div>
        </div>

        <div id="results-screen" class="hidden bg-[#1B1B1B] p-4"> 
            <h2 class="text-xl font-bold text-white text-center mb-3">Quiz Complete!</h2>
            <p id="score-text" class="text-lg text-gray-300 text-center font-semibold mb-6"></p>
            <div id="results-summary" class="space-y-4"></div>
            <div class="text-center mt-6">
                <button id="restart-btn" class="btn btn-primary">Retake Quiz</button>
            </div>
        </div>
    </main>

    <script>
        const quizData = [
            {
                question: "What is the Model Human Processor (MHP) and when was it introduced?",
                answerOptions: [
                    { text: "A computer processor model introduced in 1990", isCorrect: false },
                    { text: "A mental blueprint of human information processing introduced in 1983", isCorrect: true },
                    { text: "A model for artificial intelligence systems", isCorrect: false },
                    { text: "A physical model of the human brain", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The Model Human Processor (MHP) was introduced in 1983 as a simple way to understand how humans interact with computers. It's a mental blueprint of how we take in information, think about it, and act on it."
            },
            {
                question: "What are the three main subsystems of the Model Human Processor?",
                answerOptions: [
                    { text: "Input, Processing, Output", isCorrect: false },
                    { text: "Vision, Hearing, Touch", isCorrect: false },
                    { text: "Perceptual system, Motor system, Cognitive system", isCorrect: true },
                    { text: "Sensory memory, Short-term memory, Long-term memory", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The three main subsystems are: Perceptual system (takes in sensory information), Motor system (controls physical actions), and Cognitive system (processes and interprets information, making decisions)."
            },
            {
                question: "In the context of HCI input-output channels, what is the relationship between user output and computer input?",
                answerOptions: [
                    { text: "They are completely separate processes", isCorrect: false },
                    { text: "User output becomes computer input", isCorrect: true },
                    { text: "Computer input becomes user output", isCorrect: false },
                    { text: "They occur simultaneously without interaction", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The user's output (typing, clicking, touching) becomes the computer's input, and the computer's output (text, images, sounds) becomes the user's input."
            },
            {
                question: "Which two types of receptors in the retina are responsible for vision?",
                answerOptions: [
                    { text: "Thermoreceptors and Nociceptors", isCorrect: false },
                    { text: "Rods and Cones", isCorrect: true },
                    { text: "Rapidly adapting and Slowly adapting receptors", isCorrect: false },
                    { text: "Mechanoreceptors and Positional receptors", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The retina contains Rods (for low-light/night vision) and Cones (for color vision in brighter light). These receptors convert light into electrical signals sent to the brain."
            },
            {
                question: "What is the approximate frequency range that the human ear can detect?",
                answerOptions: [
                    { text: "5 Hz to 5 kHz", isCorrect: false },
                    { text: "20 Hz to 15 kHz", isCorrect: true },
                    { text: "50 Hz to 20 kHz", isCorrect: false },
                    { text: "100 Hz to 10 kHz", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The human ear can detect sounds with frequencies roughly between 20 Hz and 15 kHz. The auditory system filters incoming sounds to help ignore background noise and focus on important sounds."
            },
            {
                question: "Which sound characteristic determines the pitch we perceive?",
                answerOptions: [
                    { text: "Amplitude", isCorrect: false },
                    { text: "Frequency", isCorrect: true },
                    { text: "Wavelength", isCorrect: false },
                    { text: "Timbre", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "Frequency controls the pitch of a sound. High frequency = high pitch (like a whistle), Low frequency = low pitch (like a drum)."
            },
            {
                question: "What are the three main types of sensory receptors in the skin for touch perception?",
                answerOptions: [
                    { text: "Rods, Cones, Mechanoreceptors", isCorrect: false },
                    { text: "Thermoreceptors, Nociceptors, Mechanoreceptors", isCorrect: true },
                    { text: "Rapidly adapting, Slowly adapting, Positional receptors", isCorrect: false },
                    { text: "Outer ear, Middle ear, Inner ear receptors", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The skin contains Thermoreceptors (respond to heat and cold), Nociceptors (respond to intense pressure, heat, and pain), and Mechanoreceptors (respond to pressure and texture)."
            },
            {
                question: "When a person responds to something on a computer screen, what two components make up the total time taken?",
                answerOptions: [
                    { text: "Thinking time and Action time", isCorrect: false },
                    { text: "Reaction time and Movement time", isCorrect: true },
                    { text: "Perception time and Execution time", isCorrect: false },
                    { text: "Decision time and Physical time", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "Total time includes Reaction time (time to notice a stimulus and decide to act) and Movement time (time to physically carry out the action)."
            },
            {
                question: "What are the three main types of human memory according to the lecture?",
                answerOptions: [
                    { text: "Immediate, Temporary, Permanent", isCorrect: false },
                    { text: "Visual, Auditory, Kinesthetic", isCorrect: false },
                    { text: "Sensory Memory, Short-Term Memory, Long-Term Memory", isCorrect: true },
                    { text: "Working, Storage, Retrieval Memory", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "The three main types are: Sensory Memory (brief sensory information), Short-Term Memory (temporary working memory), and Long-Term Memory (permanent storage)."
            },
            {
                question: "What is the approximate duration of sensory memory?",
                answerOptions: [
                    { text: "0.5 seconds", isCorrect: true },
                    { text: "5 seconds", isCorrect: false },
                    { text: "20-30 seconds", isCorrect: false },
                    { text: "Indefinite", isCorrect: false }
                ],
                type: 'radio',
                fullExplanation: "Sensory memory is very brief â€” it lasts only about 0.5 seconds (a fraction of a second). It's important for perceiving continuous visual and auditory streams like animations and speech."
            }
        ];

        let currentQuestionIndex = 0;
        // Stores user's selected answer and correctness status: { selected: string | string[] | null, isCorrect: boolean | null, answered: boolean }
        const userAnswers = quizData.map(() => ({ selected: null, isCorrect: null, answered: false }));
        
        const quizContentEl = document.getElementById('quiz-content');
        const currentQuestionContainerEl = document.getElementById('current-question-container');
        const resultsScreenEl = document.getElementById('results-screen');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const checkAnswerBtn = document.getElementById('check-answer-btn');
        const restartBtn = document.getElementById('restart-btn');
        const feedbackAreaEl = document.getElementById('feedback-area');
        const explanationTextEl = document.getElementById('explanation-text');
        const currentQuestionNumberEl = document.getElementById('current-question-number');
        const totalQuestionsEl = document.getElementById('total-questions');

        totalQuestionsEl.textContent = quizData.length;

        // Helper to calculate current score
        function calculateScore() {
            return userAnswers.filter(a => a.isCorrect === true).length;
        }

        function renderQuestion(index) {
            const questionData = quizData[index];
            const userAnswer = userAnswers[index];
            currentQuestionContainerEl.innerHTML = `
                <div class="question-item" data-index="${index}">
                    <h2 class="text-base font-semibold text-gray-300 mb-4">${questionData.question}</h2>
                    <div class="options-container space-y-3"></div>
                </div>
            `;
            
            currentQuestionNumberEl.textContent = index + 1;

            const optionsContainer = currentQuestionContainerEl.querySelector('.options-container');
            const isAnswered = userAnswer.answered;
            const inputType = questionData.type === 'radio' ? 'radio' : 'checkbox';

            questionData.answerOptions.forEach((option, optionIndex) => {
                const optionId = `q${index}-o${optionIndex}`;
                
                const optionEl = document.createElement('label');
                optionEl.className = 'option-label flex items-center';
                optionEl.setAttribute('for', optionId);

                optionEl.innerHTML = `
                    <input type="${inputType}" id="${optionId}" name="q${index}" value="${option.text}" class="mr-3" ${isAnswered ? 'disabled' : ''}>
                    <span>${option.text}</span>
                `;
                optionsContainer.appendChild(optionEl);

                const inputEl = optionEl.querySelector('input');
                
                // Set initial selection/state
                if (questionData.type === 'radio') {
                    if (userAnswer.selected === option.text) {
                        inputEl.checked = true;
                        optionEl.classList.add('selected');
                    }
                } else { // checkbox
                    if (Array.isArray(userAnswer.selected) && userAnswer.selected.includes(option.text)) {
                        inputEl.checked = true;
                        optionEl.classList.add('selected');
                    }
                }

                // Apply correctness styling if already answered
                if (isAnswered) {
                    optionEl.classList.add('answered', 'disabled');
                    if (option.isCorrect) {
                        optionEl.classList.add('correct');
                    } else if (inputEl.checked) {
                        optionEl.classList.add('incorrect');
                    }
                }

                inputEl.addEventListener('change', (e) => handleOptionSelect(e, index));
            });

            // Update navigation buttons
            prevBtn.disabled = index === 0;

            // Next button logic
            if (index === quizData.length - 1) {
                // Last question: always change text to "Done" and enable button
                nextBtn.textContent = 'Done';
                nextBtn.disabled = false; 
            } else {
                // Not last question: always set text to "Next" and enable button (to allow skipping)
                nextBtn.textContent = 'Next';
                nextBtn.disabled = false;
            }

            // Update check button state and feedback
            if (isAnswered) {
                checkAnswerBtn.disabled = true;
                feedbackAreaEl.classList.remove('hidden');
                explanationTextEl.innerHTML = questionData.fullExplanation;
            } else {
                // Not answered yet
                checkAnswerBtn.disabled = !userAnswer.selected || (Array.isArray(userAnswer.selected) && userAnswer.selected.length === 0);
                feedbackAreaEl.classList.add('hidden');
            }
        }

        function handleOptionSelect(e, index) {
            const currentQuestion = quizData[index];
            const target = e.target;
            const labelEl = target.closest('label');
            
            if (userAnswers[index].answered) return;

            if (currentQuestion.type === 'radio') {
                userAnswers[index].selected = target.value;
                document.querySelectorAll(`input[name="q${index}"]`).forEach(input => {
                    input.closest('label').classList.remove('selected');
                });
                labelEl.classList.add('selected');
            } else { 
                if (!Array.isArray(userAnswers[index].selected)) {
                    userAnswers[index].selected = [];
                }
                let answerSet = new Set(userAnswers[index].selected);
                if (target.checked) {
                    answerSet.add(target.value);
                    labelEl.classList.add('selected');
                } else {
                    answerSet.delete(target.value);
                    labelEl.classList.remove('selected');
                }
                userAnswers[index].selected = Array.from(answerSet);
            }
            
            // Enable Check Answer button only if an option is selected
            checkAnswerBtn.disabled = !userAnswers[index].selected || (Array.isArray(userAnswers[index].selected) && userAnswers[index].selected.length === 0);
        }

        function checkAnswer() {
            const questionData = quizData[currentQuestionIndex];
            const userAnswer = userAnswers[currentQuestionIndex];
            
            // Allow checking only if an answer is selected and not already answered
            if (!userAnswer.selected || userAnswer.answered) return;

            userAnswer.answered = true;
            
            const correctAnswers = questionData.answerOptions.filter(opt => opt.isCorrect).map(opt => opt.text);
            let isCorrect = false;

            if (questionData.type === 'radio') {
                isCorrect = userAnswer.selected === correctAnswers[0];
            } else { 
                const userAnswerSet = new Set(userAnswer.selected);
                const correctAnswerSet = new Set(correctAnswers);
                isCorrect = correctAnswerSet.size === userAnswerSet.size && [...correctAnswerSet].every(item => userAnswerSet.has(item));
            }
            
            userAnswer.isCorrect = isCorrect;
            
            const inputs = document.querySelectorAll(`input[name="q${currentQuestionIndex}"]`);
            inputs.forEach(input => {
                const labelEl = input.closest('label');
                labelEl.classList.add('answered', 'disabled');
                input.disabled = true;

                const optionText = input.value;
                const isUserSelected = input.checked;
                const isCorrectOption = correctAnswers.includes(optionText);

                if (isCorrectOption) {
                    labelEl.classList.add('correct');
                } else if (isUserSelected && !isCorrectOption) {
                    labelEl.classList.add('incorrect');
                }
                labelEl.classList.remove('selected'); 
            });
            
            checkAnswerBtn.disabled = true;
            feedbackAreaEl.classList.remove('hidden');
            explanationTextEl.innerHTML = questionData.fullExplanation;
        }

        function navigate(direction) {
            if (direction === 'next') {
                if (currentQuestionIndex < quizData.length - 1) {
                    currentQuestionIndex++;
                    renderQuestion(currentQuestionIndex);
                } else if (currentQuestionIndex === quizData.length - 1) {
                    // Last question, "Done" button clicked, show results.
                    showResults(); 
                }
            } else if (direction === 'prev' && currentQuestionIndex > 0) {
                currentQuestionIndex--;
                renderQuestion(currentQuestionIndex);
            }
        }

        function showResults() {
            quizContentEl.classList.add('hidden');
            resultsScreenEl.classList.remove('hidden');

            const score = calculateScore();
            const resultsSummaryEl = document.getElementById('results-summary');
            resultsSummaryEl.innerHTML = '';

            document.getElementById('score-text').textContent = `You scored ${score} out of ${quizData.length}`;
            
            quizData.forEach((question, index) => {
                const userAnswer = userAnswers[index];
                const isCorrect = userAnswer.isCorrect;
                
                const correctAnswers = question.answerOptions.filter(opt => opt.isCorrect).map(opt => opt.text);
                const userAnswerText = Array.isArray(userAnswer.selected) ? userAnswer.selected.join(', ') : userAnswer.selected || 'Not answered';
                const correctAnswerText = correctAnswers.join(', ');
                const explanationText = question.fullExplanation || "No explanation available.";

                const resultItem = document.createElement('div');
                resultItem.className = 'p-3 border rounded-lg';
                
                // Styling based on whether it was answered and if correct
                if (userAnswer.answered) {
                    resultItem.classList.add(isCorrect ? 'border-green-500' : 'border-red-500', isCorrect ? 'bg-green-800' : 'bg-red-800');
                } else {
                    // Style for skipped/unanswered question
                    resultItem.classList.add('border-gray-500', 'bg-gray-700');
                }
                

                resultItem.innerHTML = `
                    <p class="font-semibold text-sm text-white">${index + 1}. ${question.question}</p>
                    <p class="text-xs mt-1 text-gray-300">Your answer: <span class="font-medium">${userAnswerText}</span></p>
                    <p class="text-xs mt-1 text-gray-300">Correct answer: <span class="font-medium">${correctAnswerText}</span></p>
                    ${userAnswer.answered ? `<p class="text-xs mt-2 text-gray-300">Explanation: ${explanationText}</p>` : '<p class="text-xs mt-2 text-gray-300 font-bold">Question was not answered.</p>'}
                `;
                resultsSummaryEl.appendChild(resultItem);
            });

        }

        checkAnswerBtn.addEventListener('click', checkAnswer);
        prevBtn.addEventListener('click', () => navigate('prev'));
        nextBtn.addEventListener('click', () => navigate('next'));
        
        restartBtn.addEventListener('click', () => {
            // Simple page reload to reset the state
            location.reload(); 
        });

        // Initial render
        renderQuestion(currentQuestionIndex);
    </script>
</body>
</html>